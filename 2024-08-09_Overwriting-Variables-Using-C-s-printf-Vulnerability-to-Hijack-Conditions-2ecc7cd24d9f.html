<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Overwriting Variables Using C’s printf Vulnerability to Hijack Conditions</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Overwriting Variables Using C’s printf Vulnerability to Hijack Conditions</h1>
</header>
<section data-field="subtitle" class="p-summary">
This abuses C’s printf functions in programs to over-write variables to values of our choosing. This type of exploitation is known as…
</section>
<section data-field="body" class="e-content">
<section name="7278" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="b2e1" id="b2e1" class="graf graf--h3 graf--leading graf--title">Overwriting Variables Using C’s Printf() Vulnerability to Hijack Conditions</h3><p name="1701" id="1701" class="graf graf--p graf-after--h3">This abuses C’s printf functions in programs to over-write variables to values of our choosing. This type of exploitation is known as <strong class="markup--strong markup--p-strong">BINEX. </strong>It is important to note that basic knowledge in C is required to understand this article. Everything else will be explained in-depth.</p><p name="8f4d" id="8f4d" class="graf graf--p graf-after--p">Last note: PWNTOOLS is <strong class="markup--strong markup--p-strong">required for this</strong>. This is because it will nicely bundle our input into the pipe as bytes. Otherwise every character by your terminal will be registered as a separate byte, for example A will be interpreted as:</p><blockquote name="8816" id="8816" class="graf graf--blockquote graf-after--p">1 byte = <strong class="markup--strong markup--blockquote-strong">0x</strong></blockquote><blockquote name="8064" id="8064" class="graf graf--blockquote graf-after--blockquote">1 byte = 41</blockquote><blockquote name="2abd" id="2abd" class="graf graf--blockquote graf-after--blockquote">1 byte = 41</blockquote><blockquote name="f48d" id="f48d" class="graf graf--blockquote graf-after--blockquote">etc</blockquote><p name="02bc" id="02bc" class="graf graf--p graf--hasDropCapModel graf--hasDropCap graf-after--blockquote"><span class="graf-dropCap">T</span>his is actually a PicoCTF practice named <strong class="markup--strong markup--p-strong">“Format String 2”</strong>. I struggled with this one for a few days and got a lot of help from my fellow friend Anthony. We’re given a binary and its source code and a hint that says to use “<strong class="markup--strong markup--p-strong">PWNTOOLS</strong>”.</p><figure name="60aa" id="60aa" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*CXTl-p7DOv0fJTT7bCeDdA.png" data-width="2332" data-height="1332" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*CXTl-p7DOv0fJTT7bCeDdA.png"></figure><p name="cbbb" id="cbbb" class="graf graf--p graf-after--figure">Now if we skim the code a few things stick out which I’ve circled in red. First of all we have the variable “<strong class="markup--strong markup--p-strong">sus</strong>” being compared to a hex value of “<strong class="markup--strong markup--p-strong">0x67616c66</strong>”. If the variable is equal to that it will give us our flag so we can complete this challenge. Moreover, if it does not equal that it will tell us the value of the variable and will say “you can do better”.</p><p name="0180" id="0180" class="graf graf--p graf-after--p">At first I thought maybe there’s a way to do a buffer overflow, but this is not possible because if we look at the <strong class="markup--strong markup--p-strong">scanf</strong> function it only allows the reading of 1024 characters (plus that hidden null terminator <strong class="markup--strong markup--p-strong">‘\0’</strong>).</p><p name="be54" id="be54" class="graf graf--p graf-after--p">Regardless, a stack overflow would not help us because <strong class="markup--strong markup--p-strong">sus</strong> is NOT stored in the <strong class="markup--strong markup--p-strong">stack </strong>but in the <strong class="markup--strong markup--p-strong">.DATA</strong> section of the <strong class="markup--strong markup--p-strong">ELF</strong>. I did not know this, my first thought process was to abuse how <strong class="markup--strong markup--p-strong">printf() </strong>was being called with our input on line 13 to somehow manipulate the value of <strong class="markup--strong markup--p-strong">sus</strong> or trick the program by changing the value it was being compared to of <strong class="markup--strong markup--p-strong">0x67616c66.</strong></p><p name="30b8" id="30b8" class="graf graf--p graf-after--p">You may be asking, but this is not possible because it is not in the stack! Well, I assumed that the main function was comparing a value that is not in the stack, so perhaps it would <strong class="markup--strong markup--p-strong">PUSH </strong>a register of that value onto the stack and compare it and perhaps then we would have a way of messing with it? There was a lot of assumptions being made.</p><p name="126a" id="126a" class="graf graf--p graf-after--p">Therefore, I fired up <strong class="markup--strong markup--p-strong">GHIDRA, </strong>a reverse engineering tools made by the <strong class="markup--strong markup--p-strong">NSA, </strong>and took a look at the binary’s assembly (this was provided by PicoCTF as well).</p><figure name="f00e" id="f00e" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*CNnbY4tq7ycgowI44SWEeg.png" data-width="2356" data-height="584" src="https://cdn-images-1.medium.com/max/800/1*CNnbY4tq7ycgowI44SWEeg.png"></figure><p name="3f32" id="3f32" class="graf graf--p graf-after--figure">If we look in the image there are no <strong class="markup--strong markup--p-strong">PUSH</strong> instructions which means that the register is NOT being pushed onto the stack-my assumption was wrong. But hey, this is how we learn.</p><p name="47b2" id="47b2" class="graf graf--p graf-after--p">That’s when I asked for assistance, I was told to check protections of the binary by running:</p><blockquote name="980d" id="980d" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">checksec BINARY_NAME.</strong></blockquote><p name="5ee2" id="5ee2" class="graf graf--p graf-after--blockquote">The output is below:</p><figure name="e742" id="e742" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*fFDUTEMnhKqAYPV9_PU58w.png" data-width="628" data-height="150" src="https://cdn-images-1.medium.com/max/800/1*fFDUTEMnhKqAYPV9_PU58w.png"></figure><p name="d26d" id="d26d" class="graf graf--p graf-after--figure">If you don’t know what these protections mean I’ll explain the ones I know below:</p><ol class="postList"><li name="c294" id="c294" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Stack Canary: </strong>there is a <strong class="markup--strong markup--li-strong">CANARY</strong> (similar to <strong class="markup--strong markup--li-strong">leaked web canary tokens) </strong>written to the stack and if it’s modified it will lead to “stack smashing” which crashes the program. A way to bypass this is by leaking the canary token, writing it, then traversing to the memory location you’re actually interested in.</li><li name="7e7d" id="7e7d" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">NX (No Execute): </strong>it is possible to write shellcode in the memory of the running process, then jump to it, and this will execute the shellcode in the memory space leading to a shell.</li><li name="197e" id="197e" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">PIE (Position Independent Executable): </strong>the memory space of the binary will change everytime it is run, so global variables and other values will not be constant everytime the program is run.</li><li name="1883" id="1883" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">RELRO: </strong>relative RELRO works with the <strong class="markup--strong markup--li-strong">GOT table (Global Offset Table).</strong></li></ol><p name="5755" id="5755" class="graf graf--p graf-after--li">Then it hit me I forgot-the <strong class="markup--strong markup--p-strong">sus</strong> variable we need to change is not even in the stack! We can verify this by spamming python3 “<strong class="markup--strong markup--p-strong">%p. * 100&quot;, </strong>decoding the Hex and seeing if we can find the value of <strong class="markup--strong markup--p-strong">0x21737573</strong>.</p><blockquote name="84fa" id="84fa" class="graf graf--blockquote graf-after--p">If you’re not aware of this technique read more about it <a href="https://medium.com/@alimuhammadsecured/leaking-stack-memory-using-cs-printf-formatters-b6eac6ce8864" data-href="https://medium.com/@alimuhammadsecured/leaking-stack-memory-using-cs-printf-formatters-b6eac6ce8864" class="markup--anchor markup--blockquote-anchor" target="_blank">here</a>:</blockquote><p name="77c1" id="77c1" class="graf graf--p graf-after--blockquote">Turns out a string formatter we can use to over-write the global variable that is not restricted to the <strong class="markup--strong markup--p-strong">stack, but ANY writeable memory region </strong>(let’s gooo) is “<strong class="markup--strong markup--p-strong">%n</strong>”.</p><blockquote name="6aa4" id="6aa4" class="graf graf--blockquote graf-after--p">If you’re new to Binex watch tutorials from Pwn.college they will teach everything from A-Z <a href="https://pwn.college/" data-href="https://pwn.college/" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">here</a>.</blockquote><p name="f889" id="f889" class="graf graf--p graf-after--blockquote">The way %n works is it writes the bytes printed out to a memory location we specify. Therefore, since we need to write “<strong class="markup--strong markup--p-strong">0x67616c66</strong>” into sus we need to print that many bytes which is <strong class="markup--strong markup--p-strong">1734437990 bytes.</strong></p><p name="eea3" id="eea3" class="graf graf--p graf-after--p">So our payload will start with this (we will be using PWNTOOLS):</p><blockquote name="b9f2" id="b9f2" class="graf graf--blockquote graf-after--p">b”%<strong class="markup--strong markup--blockquote-strong">1734437990x</strong>”</blockquote><p name="5e68" id="5e68" class="graf graf--p graf-after--blockquote">okay, now we need to use the format specifier and we need to tell it what offset to write to. For example, %n needs to know which memory cell to write to. So we need to run the <strong class="markup--strong markup--p-strong">file command </strong>to figure out what architecture our target system is running on.</p><figure name="ea11" id="ea11" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*EM-vsA7L0xJX0of7vV7Gbw.png" data-width="576" data-height="92" src="https://cdn-images-1.medium.com/max/800/1*EM-vsA7L0xJX0of7vV7Gbw.png"></figure><p name="d6ba" id="d6ba" class="graf graf--p graf-after--figure">Alright, just like last time it’s running on a 64-bit, so every memory cell is <strong class="markup--strong markup--p-strong">8 bytes. </strong>If it was 32-bit every memory cell would be <strong class="markup--strong markup--p-strong">4 bytes.</strong></p><p name="db7d" id="db7d" class="graf graf--p graf-after--p">This is crucial to finding out <strong class="markup--strong markup--p-strong">“where we are” </strong>in terms of offsets in the stack. Like last time we explained that our string that’s passed into the <strong class="markup--strong markup--p-strong">printf</strong> function is actually stored on the stack and is in the memory. Therefore, if we’re writing to a memory location of a variable we want we need to make sure we write to the right memory cell depending on where we are.</p><p name="ab45" id="ab45" class="graf graf--p graf-after--p">In order to figure out where we are in memory (our input) we can send in <strong class="markup--strong markup--p-strong">8 bytes </strong>of input and append %x’s to find our offset.</p><figure name="c16f" id="c16f" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*j5PD4vvY978g9GdKqcNQdg.png" data-width="696" data-height="140" src="https://cdn-images-1.medium.com/max/800/1*j5PD4vvY978g9GdKqcNQdg.png"></figure><p name="4b32" id="4b32" class="graf graf--p graf-after--figure">Alright, so 0x4141… is the correct HEX representation of AAAAAAAA, so our offset is <strong class="markup--strong markup--p-strong">14</strong> from the initial input on the stack. Now all we need to do now is find the address of the variable we want to change.</p><p name="b6b9" id="b6b9" class="graf graf--p graf-after--p">Because <strong class="markup--strong markup--p-strong">sus </strong>is a global variable stored in <strong class="markup--strong markup--p-strong">.DATA</strong> and PIE is disabled it means that it will be the same address everytime we run our program. This is good for us, so after running GHIDRA we just double click <strong class="markup--strong markup--p-strong">sus </strong>and copy its address.</p><figure name="7705" id="7705" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*Zo237_jiQ8f-3DhZSDTzJA.png" data-width="762" data-height="72" src="https://cdn-images-1.medium.com/max/800/1*Zo237_jiQ8f-3DhZSDTzJA.png"></figure><p name="9caa" id="9caa" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">0x00404060 =&gt; where sus lives</strong> (with value of what we expect)</p><p name="e46e" id="e46e" class="graf graf--p graf-after--p">we have to represent the address in little endian because of how the stack is used, I will explain this in just a bit, for now we’ll just use the <strong class="markup--strong markup--p-strong">p64( address) </strong>function <strong class="markup--strong markup--p-strong">pwntools</strong> provides us to convert a hexadecimal address into a 64 bit little endian byte representation. Once I give the explanation to why we’re using little endian and why everything has a very strict order you will understand why we had to swap endianness last time to get the correct flag.</p><p name="1028" id="1028" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Visual of Stack:</strong></p><figure name="3419" id="3419" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*r7Sdvd9Euw06CEtUlWSdlg.png" data-width="960" data-height="720" src="https://cdn-images-1.medium.com/max/800/1*r7Sdvd9Euw06CEtUlWSdlg.png"><figcaption class="imageCaption">Remember: HEAP stores dynamic data created with <strong class="markup--strong markup--figure-strong">malloc()</strong>, where as the stack stores <strong class="markup--strong markup--figure-strong">automatic data</strong>. Variables, functions, etc.</figcaption></figure><p name="a2b1" id="a2b1" class="graf graf--p graf-after--figure">Here’s how our payload looks so far:</p><blockquote name="81e2" id="81e2" class="graf graf--blockquote graf-after--p">bytes of value we want to write + format specifier (%_OFFSET_$n) + p64( target_variable_address )</blockquote><figure name="24ef" id="24ef" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="1*DZSbDtq7IR-CqoDWrHFrQg.png" data-width="1114" data-height="54" src="https://cdn-images-1.medium.com/max/800/1*DZSbDtq7IR-CqoDWrHFrQg.png"></figure><p name="65ee" id="65ee" class="graf graf--p graf-after--figure">Remember, every memory cell needs to be <strong class="markup--strong markup--p-strong">8 bytes</strong>, so I added some padding to meet that requirement. The offset is <strong class="markup--strong markup--p-strong">17</strong>.</p><p name="06dc" id="06dc" class="graf graf--p graf-after--p">Unfortunately, this will not work because printing our over 1 BILLION bytes onto the screen is insane and causes the pipe connection to crash. So we need to utilize a method known as <strong class="markup--strong markup--p-strong">half-writes</strong>. Half-writes write per 2 bytes and decrease the amount of bytes printed out onto the screen.</p><figure name="9670" id="9670" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*mMMRd-dzSZANvf-Yubydog.png" data-width="1580" data-height="1082" src="https://cdn-images-1.medium.com/max/800/1*mMMRd-dzSZANvf-Yubydog.png"><figcaption class="imageCaption">NOTE: we’re writing 26465 bytes (<strong class="markup--strong markup--figure-strong">0x6761 in HEX</strong>). Note how we added <strong class="markup--strong markup--figure-strong">+2</strong> to the <strong class="markup--strong markup--figure-strong">sus </strong>address to get to the last 2 bytes (which are the left-most because of little ENDIAN, I know super weird). The offset of this is 18 so we write to that. Then continue that by writing the remaining bytes into offset 19 for the first two bytes.</figcaption></figure><figure name="6e64" id="6e64" class="graf graf--figure graf-after--figure"><img class="graf-image" data-image-id="1*7RffQs2O6UCwakswVfXb_Q.png" data-width="1484" data-height="218" src="https://cdn-images-1.medium.com/max/800/1*7RffQs2O6UCwakswVfXb_Q.png"></figure><p name="816f" id="816f" class="graf graf--p graf-after--figure">NOTE: every byte in HEX is two 2-digit numbers, and the order is backwards because of little endian <strong class="markup--strong markup--p-strong">right-left</strong> instead of <strong class="markup--strong markup--p-strong">left-right</strong>.</p><p name="70c9" id="70c9" class="graf graf--p graf-after--p">First we need to split up value you want to over-write <strong class="markup--strong markup--p-strong">SUS</strong> with:</p><p name="a3f1" id="a3f1" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">6761</strong> <strong class="markup--strong markup--p-strong">6c66</strong></p><p name="5892" id="5892" class="graf graf--p graf-after--p">here is a 2 byte representation:</p><p name="4d2b" id="4d2b" class="graf graf--p graf-after--p">(Because of <strong class="markup--strong markup--p-strong">Little Endian</strong>):</p><p name="239f" id="239f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Second</strong> 2 bytes:[ 67 61 ]</p><p name="7081" id="7081" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">First</strong> 2 bytes: [6c 66]</p><p name="36fb" id="36fb" class="graf graf--p graf-after--p">Now we’re going to show the representation of each of these numbers in decimal since that’s how we write using %n.</p><p name="30ff" id="30ff" class="graf graf--p graf-after--p">6761 = <strong class="markup--strong markup--p-strong">26465</strong></p><p name="d694" id="d694" class="graf graf--p graf-after--p">6c66 = <strong class="markup--strong markup--p-strong">27750</strong></p><p name="583a" id="583a" class="graf graf--p graf-after--p"># 27750–26465 = 1285 bytes left to write because we’re no longer starting at <strong class="markup--strong markup--p-strong">zero on the stack, we’ve already written 26465 bytes so we need to write 1285 more bytes.</strong></p><figure name="cb71" id="cb71" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*vdQdGAmvI0dazXg6wPdAqw.png" data-width="2356" data-height="1166" src="https://cdn-images-1.medium.com/max/800/1*vdQdGAmvI0dazXg6wPdAqw.png"></figure><p name="b4ee" id="b4ee" class="graf graf--p graf-after--figure">ALAS! All code is below on my Github and a bunch of writeups from my colleague Anthony:</p><p name="f9c8" id="f9c8" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Last Note</strong>: using <strong class="markup--strong markup--p-strong">PWNDEBUG</strong> locally to test these kinds of exploits, see how your variables are changing and from there it speeds up the process and reduces numerous headaches along the way.</p><p name="8c2e" id="8c2e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Code for this exploit: </strong><a href="https://github.com/BestDevOfc/Binary-Exploitation-PicoCTF/blob/main/format%20string%202/main.py" data-href="https://github.com/BestDevOfc/Binary-Exploitation-PicoCTF/blob/main/format%20string%202/main.py" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/BestDevOfc/Binary-Exploitation-PicoCTF/blob/main/format%20string%202/main.py</a></p><p name="0d7e" id="0d7e" class="graf graf--p graf-after--p graf--trailing"><strong class="markup--strong markup--p-strong">Writeups from Colleague (Anthony)</strong>: <a href="https://github.com/AnthonyMarrongelli" data-href="https://github.com/AnthonyMarrongelli" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/AnthonyMarrongelli</a></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@alimuhammadsecured" class="p-author h-card">Alimuhammadsecured</a> on <a href="https://medium.com/p/2ecc7cd24d9f"><time class="dt-published" datetime="2024-08-09T05:15:33.469Z">August 9, 2024</time></a>.</p><p><a href="https://medium.com/@alimuhammadsecured/overwriting-variables-using-cs-printf-vulnerability-to-hijack-conditions-2ecc7cd24d9f" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on August 14, 2024.</p></footer></article></body></html>